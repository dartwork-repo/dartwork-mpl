# Layout 도구 활용 가이드

## 1. 개요 및 목적

이 가이드는 `dartwork-mpl`의 `simple_layout` 함수를 사용하여 논문 품질의 그래프를 작성할 때 준수해야 하는 레이아웃 도구 활용 방법을 설명합니다.

`simple_layout`은 matplotlib의 `tight_layout()`을 개선한 함수로, GridSpec의 파라미터를 최적화하여 axes의 레이아웃을 자동으로 조정합니다. 하지만 이 함수의 작동 원리와 한계를 이해하지 못하면 예상치 못한 결과를 얻을 수 있습니다.

## 2. simple_layout의 작동 원리

### 2.1 기본 작동 방식

`simple_layout` 함수는 다음과 같이 작동합니다:

1. **GridSpec 파라미터 최적화**: 주어진 GridSpec의 `left`, `right`, `bottom`, `top` 파라미터를 조정합니다.

2. **Tightbbox 계산**: GridSpec에 포함된 axes들의 모든 `tightbbox`를 계산하고, 이를 포함하는 최소 bounding box를 구합니다.

3. **Target Bbox 설정**: `bbox` 파라미터로 지정된 target bbox에 `margins`를 고려한 위치를 계산합니다.

4. **최적화 수행**: axes의 tightbbox가 target bbox에 맞아 들어가도록 GridSpec의 파라미터를 최적화합니다.

### 2.2 최적화 알고리즘

```python
def fun(x: np.ndarray) -> float:
    # x = [left, right, bottom, top] (GridSpec 파라미터)
    gs.update(left=x[0], right=x[1], bottom=x[2], top=x[3])
    
    # 모든 axes의 tightbbox 수집
    ax_bboxes = [ax.get_tightbbox() for ax in fig.axes]
    
    # 모든 tightbbox를 포함하는 최소 bbox 계산
    all_bbox = get_bounding_box(ax_bboxes)
    
    # Target bbox 계산 (figure 좌표계 + margins)
    targets = [
        fbox.width * bbox[0] + margins[0],      # left
        fbox.height * bbox[2] + margins[2],    # bottom
        fbox.width * (bbox[1] - bbox[0]) - 2 * margins[1],   # width
        fbox.height * (bbox[3] - bbox[2]) - 2 * margins[3],  # height
    ]
    
    # Loss 계산 및 최적화
    loss = np.square((values - targets) / scales * importance_weights).sum()
    return loss
```

### 2.3 주요 파라미터

- **`gs`**: 최적화할 GridSpec 객체 (None이면 첫 번째 GridSpec 사용)
- **`margins`**: 인치 단위의 여백 (left, right, bottom, top)
- **`bbox`**: figure 좌표계에서의 최적화 대상 영역 (left, right, bottom, top)
- **`use_all_axes`**: True면 모든 axes를 고려, False면 지정된 GridSpec의 axes만 고려
- **`importance_weights`**: 각 방향(left, right, bottom, top)의 최적화 가중치

## 3. 기본 사용법

### 3.1 가장 간단한 사용법

```python
import numpy as np
import matplotlib.pyplot as plt
import dartwork_mpl as dm

# 스타일 설정
dm.style.use_preset('scientific')

# 데이터 생성
x = np.linspace(0, 10, 100)
y = np.sin(x)

# Figure 생성
fig = plt.figure(figsize=(dm.cm2in(9), dm.cm2in(7)), dpi=200)

# GridSpec 생성
gs = fig.add_gridspec(
    nrows=1, ncols=1,
    left=0.17, right=0.95,
    top=0.95, bottom=0.17
)
ax = fig.add_subplot(gs[0, 0])

# 플롯
ax.plot(x, y, color='dm.red5', linewidth=0.7)
ax.set_xlabel('X value [Hour]', fontsize=dm.fs(0))
ax.set_ylabel('Y value [kW]', fontsize=dm.fs(0))

# 레이아웃 최적화
dm.simple_layout(fig)

# 결과 확인
dm.save_and_show(fig)
```

### 3.2 여백 조정

```python
# 인치 단위로 여백 지정 (left, right, bottom, top)
dm.simple_layout(fig, margins=(0.1, 0.05, 0.1, 0.05))
```

### 3.3 특정 GridSpec 지정

```python
# 여러 GridSpec이 있을 때 특정 GridSpec만 최적화
dm.simple_layout(fig, gs=gs, margins=(0.08, 0.02, 0.08, 0.02))
```

### 3.4 bbox를 사용한 부분 영역 최적화

```python
# 전체 figure 최적화 (기본값)
dm.simple_layout(fig, bbox=(0, 1, 0, 1))

# figure의 왼쪽 절반에만 최적화
dm.simple_layout(fig, bbox=(0, 0.5, 0, 1))

# figure의 오른쪽 절반에만 최적화
dm.simple_layout(fig, bbox=(0.5, 1, 0, 1))

# figure의 상단 절반에만 최적화
dm.simple_layout(fig, bbox=(0, 1, 0.5, 1))
```

## 4. 하드코딩 요소와의 충돌 문제

### 4.1 문제 상황

`simple_layout`은 **GridSpec에 포함된 axes의 tightbbox만 고려**합니다. 따라서 figure 좌표계에 직접 배치된 요소들(`fig.text()`, `fig.legend()`, `fig.suptitle()` 등)은 최적화 과정에서 고려되지 않습니다.

**예시: 문제가 발생하는 경우**

```python
import numpy as np
import matplotlib.pyplot as plt
import dartwork_mpl as dm

dm.style.use_preset('scientific')

# 데이터
x = np.linspace(0, 10, 100)
y = np.sin(x)

# Figure 생성
fig = plt.figure(figsize=(dm.cm2in(9), dm.cm2in(7)), dpi=200)

# GridSpec 생성
gs = fig.add_gridspec(
    nrows=1, ncols=1,
    left=0.17, right=0.95,
    top=0.95, bottom=0.17
)
ax = fig.add_subplot(gs[0, 0])

# 플롯
ax.plot(x, y, color='dm.red5', linewidth=0.7)
ax.set_xlabel('X value [Hour]', fontsize=dm.fs(0))
ax.set_ylabel('Y value [kW]', fontsize=dm.fs(0))

# 하드코딩된 title (figure 좌표계)
fig.text(0.5, 0.98, 'Title', 
         fontsize=dm.fs(2), fontweight=dm.fw(1),
         ha='center', va='top')

# 레이아웃 최적화
dm.simple_layout(fig)

# 문제: title이 axes와 겹칠 수 있음!
dm.save_and_show(fig)
```

### 4.2 왜 최적화가 불가능한가?

1. **Figure 좌표계 요소는 tightbbox에 포함되지 않음**: `fig.text()` 등으로 배치된 요소는 axes의 tightbbox 계산에 포함되지 않습니다.

2. **최적화 대상이 GridSpec 파라미터뿐**: `simple_layout`은 GridSpec의 `left`, `right`, `bottom`, `top`만 조정하므로, figure 좌표계에 직접 배치된 요소의 위치는 변경할 수 없습니다.

3. **충돌 발생**: 최적화 과정에서 axes가 확장되면 하드코딩된 요소와 겹칠 수 있습니다.

## 5. 해법 1: bbox를 작게 설정하여 하드코딩 요소 공간 확보

### 5.1 기본 원리

하드코딩된 요소가 있을 위치를 미리 계산하고, GridSpec이 배치될 bbox를 그보다 작게 설정합니다. 이렇게 하면 최적화 과정에서 axes가 하드코딩된 요소 영역을 침범하지 않습니다.

### 5.2 예시: Title과 Legend가 있는 경우

```python
import numpy as np
import matplotlib.pyplot as plt
import dartwork_mpl as dm

dm.style.use_preset('scientific')

# 데이터
x = np.linspace(0, 10, 100)
y1 = np.sin(x)
y2 = np.cos(x)

# Figure 생성
fig = plt.figure(figsize=(dm.cm2in(12), dm.cm2in(12)), dpi=200)

# Cascading layout calculation
# 1. Title 위치 (figure 좌표계)
title_y = 0.98

# 2. Legend 위치 (title 아래에 배치)
title_to_legend_gap = 0.05
legend_y = title_y - title_to_legend_gap

# 3. Figure top (legend 아래에 배치)
legend_to_figure_gap = 0.03
figure_top = legend_y - legend_to_figure_gap

# 4. Figure bottom
figure_bottom = 0.1

# 5. 좌우 마진
left_margin = 0.17
right_margin = 0.95

# GridSpec 생성 (title과 legend 공간을 제외한 영역)
gs = fig.add_gridspec(
    nrows=1, ncols=1,
    left=left_margin,
    right=right_margin,
    top=figure_top,      # title과 legend 아래
    bottom=figure_bottom
)
ax = fig.add_subplot(gs[0, 0])

# 플롯
line1, = ax.plot(x, y1, color='dm.red5', linewidth=0.7, label='Sin')
line2, = ax.plot(x, y2, color='dm.blue5', linewidth=0.7, label='Cos')
ax.set_xlabel('X value [Hour]', fontsize=dm.fs(0))
ax.set_ylabel('Y value [kW]', fontsize=dm.fs(0))

# 하드코딩된 title (figure 좌표계)
fig.text(0.5, title_y, 'Comparison Plot', 
         fontsize=dm.fs(2), fontweight=dm.fw(1),
         ha='center', va='top')

# 하드코딩된 legend (figure 좌표계)
fig.legend([line1, line2], ['Sin', 'Cos'],
           bbox_to_anchor=(0.5, legend_y),
           loc='center', ncol=2,
           fontsize=dm.fs(-1))

# 레이아웃 최적화
# bbox를 사용하여 axes 영역만 최적화
# title과 legend가 있는 영역은 bbox 밖에 두어 보호
dm.simple_layout(
    fig,
    gs=gs,
    bbox=(left_margin, right_margin, figure_bottom, figure_top),
    use_all_axes=False,  # 이 GridSpec의 axes만 최적화
)

dm.save_and_show(fig)
```

### 5.3 주의사항

- **Cascading 계산**: 위에서 아래로 순차적으로 계산하여 각 요소의 위치를 결정합니다.
- **충분한 여백 확보**: 요소 간 간격을 충분히 확보하여 겹침을 방지합니다.
- **bbox 범위**: `bbox` 파라미터는 figure 좌표계에서 axes가 배치될 수 있는 영역을 지정합니다.

## 6. 해법 2: axes_divider를 사용한 상대 위치 지정

### 6.1 기본 원리

`mpl_toolkits.axes_grid1`의 `make_axes_locatable`를 사용하여 다른 axes에 대한 상대 위치로 요소를 배치합니다. 이렇게 하면 axes의 위치가 변경되어도 상대적 위치가 유지됩니다.

### 6.2 예시: Colorbar를 axes 옆에 배치

```python
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable
import dartwork_mpl as dm

dm.style.use_preset('scientific')

# 데이터
x = np.linspace(0, 10, 100)
y = np.linspace(0, 10, 100)
X, Y = np.meshgrid(x, y)
Z = np.sin(X) * np.cos(Y)

# Figure 생성
fig = plt.figure(figsize=(dm.cm2in(9), dm.cm2in(7)), dpi=200)

# GridSpec 생성
gs = fig.add_gridspec(
    nrows=1, ncols=1,
    left=0.17, right=0.95,
    top=0.95, bottom=0.17
)
ax = fig.add_subplot(gs[0, 0])

# 플롯
im = ax.contourf(X, Y, Z, cmap='dm.Spectral', levels=20)
ax.set_xlabel('X value', fontsize=dm.fs(0))
ax.set_ylabel('Y value', fontsize=dm.fs(0))

# axes_divider를 사용하여 colorbar axes 생성
# 이 axes는 ax에 상대적으로 배치되므로
# simple_layout이 ax를 최적화해도 함께 이동함
divider = make_axes_locatable(ax)
cax = divider.append_axes("right", size="5%", pad=0.12)
cbar = fig.colorbar(im, cax=cax)
cbar.set_label('Intensity', fontsize=dm.fs(-1))
cbar.ax.tick_params(labelsize=dm.fs(-1))

# 레이아웃 최적화
# colorbar는 ax에 상대적으로 배치되어 있으므로
# ax가 최적화되면 함께 이동함
dm.simple_layout(fig, gs=gs)

dm.save_and_show(fig)
```

### 6.3 장점과 단점

**장점:**
- axes의 위치가 변경되어도 상대적 위치가 유지됨
- `simple_layout` 최적화와 호환됨

**단점:**
- `make_axes_locatable`를 사용해야 하므로 추가 import 필요
- 모든 요소에 적용할 수는 없음 (colorbar, inset axes 등에 적합)

## 7. 해법 3: GridSpec 내부에 text를 포함하는 axes 생성

### 7.1 기본 원리

하드코딩된 요소를 별도의 axes로 만들어 GridSpec에 포함시킵니다. 이렇게 하면 해당 요소도 tightbbox 계산에 포함되어 최적화 과정에서 고려됩니다.

### 7.2 예시: Title을 axes로 만들기

```python
import numpy as np
import matplotlib.pyplot as plt
import dartwork_mpl as dm

dm.style.use_preset('scientific')

# 데이터
x = np.linspace(0, 10, 100)
y = np.sin(x)

# Figure 생성
fig = plt.figure(figsize=(dm.cm2in(9), dm.cm2in(7)), dpi=200)

# GridSpec을 2행으로 분할
# 첫 번째 행: title용 (작은 높이)
# 두 번째 행: plot용 (나머지 공간)
gs = fig.add_gridspec(
    nrows=2, ncols=1,
    left=0.17, right=0.95,
    top=0.95, bottom=0.17,
    hspace=0,  # 행 간 간격 없음
    height_ratios=[0.1, 0.9]  # title: 10%, plot: 90%
)

# Title axes
ax_title = fig.add_subplot(gs[0, 0])
ax_title.axis('off')  # 축 숨김
ax_title.text(0.5, 0.5, 'Title', 
              fontsize=dm.fs(2), fontweight=dm.fw(1),
              ha='center', va='center',
              transform=ax_title.transAxes)

# Plot axes
ax = fig.add_subplot(gs[1, 0])
ax.plot(x, y, color='dm.red5', linewidth=0.7)
ax.set_xlabel('X value [Hour]', fontsize=dm.fs(0))
ax.set_ylabel('Y value [kW]', fontsize=dm.fs(0))

# 레이아웃 최적화
# title axes도 GridSpec에 포함되어 있으므로
# tightbbox 계산에 포함되어 최적화됨
dm.simple_layout(fig, gs=gs)

dm.save_and_show(fig)
```

### 7.3 예시: 복잡한 레이아웃 (Title + Legend + Plot)

```python
import numpy as np
import matplotlib.pyplot as plt
import dartwork_mpl as dm

dm.style.use_preset('scientific')

# 데이터
x = np.linspace(0, 10, 100)
y1 = np.sin(x)
y2 = np.cos(x)

# Figure 생성
fig = plt.figure(figsize=(dm.cm2in(12), dm.cm2in(12)), dpi=200)

# GridSpec을 3행으로 분할
# 첫 번째 행: title용
# 두 번째 행: legend용
# 세 번째 행: plot용
gs = fig.add_gridspec(
    nrows=3, ncols=1,
    left=0.17, right=0.95,
    top=0.95, bottom=0.1,
    hspace=0,  # 행 간 간격 없음
    height_ratios=[0.08, 0.08, 0.84]  # title: 8%, legend: 8%, plot: 84%
)

# Title axes
ax_title = fig.add_subplot(gs[0, 0])
ax_title.axis('off')
ax_title.text(0.5, 0.5, 'Comparison Plot', 
              fontsize=dm.fs(2), fontweight=dm.fw(1),
              ha='center', va='center',
              transform=ax_title.transAxes)

# Legend axes
ax_legend = fig.add_subplot(gs[1, 0])
ax_legend.axis('off')
# 더미 플롯 (legend용)
line1_dummy, = ax_legend.plot(
    [], [], color='dm.red5', linewidth=0.7, label='Sin'
)
line2_dummy, = ax_legend.plot(
    [], [], color='dm.blue5', linewidth=0.7, label='Cos'
)
ax_legend.legend([line1_dummy, line2_dummy], ['Sin', 'Cos'],
                 loc='center', ncol=2,
                 fontsize=dm.fs(-1))

# Plot axes
ax = fig.add_subplot(gs[2, 0])
line1, = ax.plot(x, y1, color='dm.red5', linewidth=0.7)
line2, = ax.plot(x, y2, color='dm.blue5', linewidth=0.7)
ax.set_xlabel('X value [Hour]', fontsize=dm.fs(0))
ax.set_ylabel('Y value [kW]', fontsize=dm.fs(0))

# 레이아웃 최적화
# 모든 axes가 GridSpec에 포함되어 있으므로
# 모두 tightbbox 계산에 포함되어 최적화됨
dm.simple_layout(fig, gs=gs)

dm.save_and_show(fig)
```

### 7.4 장점과 단점

**장점:**
- 모든 요소가 GridSpec에 포함되어 `simple_layout`과 완벽하게 호환됨
- 요소 간 상대적 위치가 자동으로 유지됨

**단점:**
- GridSpec 구조가 복잡해질 수 있음
- `height_ratios`나 `width_ratios`를 적절히 조정해야 함

## 8. 해법 4: 독립적인 GridSpec 사용

### 8.1 기본 원리

여러 개의 독립적인 GridSpec을 생성하고, 각각에 대해 별도로 `simple_layout`을 호출합니다. 이렇게 하면 각 GridSpec이 독립적으로 최적화되어 서로 간섭하지 않습니다.

### 8.2 예시: 좌우 분할 레이아웃

```python
import numpy as np
import matplotlib.pyplot as plt
import dartwork_mpl as dm

dm.style.use_preset('scientific')

# 데이터
x = np.linspace(0, 10, 100)
y1 = np.sin(x)
y2 = np.cos(x)

# Figure 생성
fig = plt.figure(figsize=(dm.cm2in(17), dm.cm2in(7)), dpi=200)

# 왼쪽 GridSpec (전체 높이의 60% 사용)
gs_left = fig.add_gridspec(
    nrows=1, ncols=1,
    left=0.1, right=0.48,  # 왼쪽 절반
    top=0.95, bottom=0.15
)
ax_left = fig.add_subplot(gs_left[0, 0])
ax_left.plot(x, y1, color='dm.red5', linewidth=0.7)
ax_left.set_xlabel('X value [Hour]', fontsize=dm.fs(0))
ax_left.set_ylabel('Y value [kW]', fontsize=dm.fs(0))
ax_left.set_title('Left Plot', fontsize=dm.fs(1))

# 오른쪽 GridSpec (전체 높이의 60% 사용)
gs_right = fig.add_gridspec(
    nrows=1, ncols=1,
    left=0.52, right=0.9,  # 오른쪽 절반
    top=0.95, bottom=0.15
)
ax_right = fig.add_subplot(gs_right[0, 0])
ax_right.plot(x, y2, color='dm.blue5', linewidth=0.7)
ax_right.set_xlabel('X value [Hour]', fontsize=dm.fs(0))
ax_right.set_ylabel('Y value [kW]', fontsize=dm.fs(0))
ax_right.set_title('Right Plot', fontsize=dm.fs(1))

# 각 GridSpec을 독립적으로 최적화
# 왼쪽 GridSpec 최적화
dm.simple_layout(
    fig,
    gs=gs_left,
    bbox=(0.1, 0.48, 0.15, 0.95),  # 왼쪽 영역만
    use_all_axes=False
)

# 오른쪽 GridSpec 최적화
dm.simple_layout(
    fig,
    gs=gs_right,
    bbox=(0.52, 0.9, 0.15, 0.95),  # 오른쪽 영역만
    use_all_axes=False
)

dm.save_and_show(fig)
```

### 8.3 예시: 상하 분할 레이아웃

```python
import numpy as np
import matplotlib.pyplot as plt
import dartwork_mpl as dm

dm.style.use_preset('scientific')

# 데이터
x = np.linspace(0, 10, 100)
y1 = np.sin(x)
y2 = np.cos(x)

# Figure 생성
fig = plt.figure(figsize=(dm.cm2in(9), dm.cm2in(14)), dpi=200)

# 상단 GridSpec
gs_top = fig.add_gridspec(
    nrows=1, ncols=1,
    left=0.17, right=0.95,
    top=0.95, bottom=0.52  # 상단 절반
)
ax_top = fig.add_subplot(gs_top[0, 0])
ax_top.plot(x, y1, color='dm.red5', linewidth=0.7)
ax_top.set_xlabel('X value [Hour]', fontsize=dm.fs(0))
ax_top.set_ylabel('Y value [kW]', fontsize=dm.fs(0))
ax_top.set_title('Top Plot', fontsize=dm.fs(1))

# 하단 GridSpec
gs_bottom = fig.add_gridspec(
    nrows=1, ncols=1,
    left=0.17, right=0.95,
    top=0.48, bottom=0.1  # 하단 절반
)
ax_bottom = fig.add_subplot(gs_bottom[0, 0])
ax_bottom.plot(x, y2, color='dm.blue5', linewidth=0.7)
ax_bottom.set_xlabel('X value [Hour]', fontsize=dm.fs(0))
ax_bottom.set_ylabel('Y value [kW]', fontsize=dm.fs(0))
ax_bottom.set_title('Bottom Plot', fontsize=dm.fs(1))

# 각 GridSpec을 독립적으로 최적화
# 상단 GridSpec 최적화
dm.simple_layout(
    fig,
    gs=gs_top,
    bbox=(0.17, 0.95, 0.52, 0.95),  # 상단 영역만
    use_all_axes=False
)

# 하단 GridSpec 최적화
dm.simple_layout(
    fig,
    gs=gs_bottom,
    bbox=(0.17, 0.95, 0.1, 0.48),  # 하단 영역만
    use_all_axes=False
)

dm.save_and_show(fig)
```

### 8.4 장점과 단점

**장점:**
- 각 GridSpec이 독립적으로 최적화되어 서로 간섭하지 않음
- 복잡한 레이아웃에서 유연하게 대응 가능

**단점:**
- 여러 번의 `simple_layout` 호출이 필요함
- 각 GridSpec의 bbox를 정확히 계산해야 함

## 9. 해법 5: 복합 해법 (여러 방법 조합)

### 9.1 기본 원리

실제로는 여러 해법을 조합하여 사용하는 경우가 많습니다. 예를 들어:
- Title은 GridSpec 내부 axes로 만들고
- Legend는 axes_divider로 만들고
- Colorbar는 axes_divider로 만들고
- 전체는 하나의 GridSpec으로 관리

### 9.2 예시: 복합 레이아웃

```python
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable
import dartwork_mpl as dm

dm.style.use_preset('scientific')

# 데이터
x = np.linspace(0, 10, 100)
y = np.linspace(0, 10, 100)
X, Y = np.meshgrid(x, y)
Z = np.sin(X) * np.cos(Y)

# Figure 생성
fig = plt.figure(figsize=(dm.cm2in(12), dm.cm2in(12)), dpi=200)

# GridSpec을 2행으로 분할
# 첫 번째 행: title용
# 두 번째 행: plot용
gs = fig.add_gridspec(
    nrows=2, ncols=1,
    left=0.17, right=0.95,
    top=0.95, bottom=0.1,
    hspace=0,
    height_ratios=[0.1, 0.9]
)

# Title axes
ax_title = fig.add_subplot(gs[0, 0])
ax_title.axis('off')
ax_title.text(0.5, 0.5, 'Contour Plot with Colorbar', 
              fontsize=dm.fs(2), fontweight=dm.fw(1),
              ha='center', va='center',
              transform=ax_title.transAxes)

# Plot axes
ax = fig.add_subplot(gs[1, 0])
im = ax.contourf(X, Y, Z, cmap='dm.Spectral', levels=20)
ax.set_xlabel('X value', fontsize=dm.fs(0))
ax.set_ylabel('Y value', fontsize=dm.fs(0))

# axes_divider를 사용하여 colorbar axes 생성
divider = make_axes_locatable(ax)
cax = divider.append_axes("right", size="5%", pad=0.12)
cbar = fig.colorbar(im, cax=cax)
cbar.set_label('Intensity', fontsize=dm.fs(-1))
cbar.ax.tick_params(labelsize=dm.fs(-1))

# 레이아웃 최적화
# title axes와 plot axes는 GridSpec에 포함되어 있으므로
# tightbbox 계산에 포함되어 최적화됨
# colorbar는 axes_divider로 생성되어 ax에 상대적으로 배치되므로
# ax가 최적화되면 함께 이동함
dm.simple_layout(fig, gs=gs)

dm.save_and_show(fig)
```

## 10. 확장성: 모든 요소에 적용 가능

### 10.1 적용 가능한 요소들

위에서 설명한 해법들은 text뿐만 아니라 다음과 같은 모든 요소에 적용 가능합니다:

- **Text**: `fig.text()`, `ax.text()`
- **Title**: `fig.suptitle()`, `ax.set_title()`
- **Legend**: `fig.legend()`, `ax.legend()`
- **Colorbar**: `fig.colorbar()`
- **Inset axes**: `inset_axes()`
- **Annotation**: `fig.annotate()`, `ax.annotate()`
- **기타 figure 좌표계 요소**: 모든 `fig.*` 메서드로 생성된 요소

### 10.2 예시: 다양한 요소가 있는 복잡한 레이아웃

```python
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable
import dartwork_mpl as dm

dm.style.use_preset('scientific')

# 데이터
x = np.linspace(0, 10, 100)
y = np.sin(x)

# Figure 생성
fig = plt.figure(figsize=(dm.cm2in(12), dm.cm2in(12)), dpi=200)

# GridSpec을 3행으로 분할
# 첫 번째 행: title용
# 두 번째 행: legend용
# 세 번째 행: plot용
gs = fig.add_gridspec(
    nrows=3, ncols=1,
    left=0.17, right=0.95,
    top=0.95, bottom=0.1,
    hspace=0,
    height_ratios=[0.08, 0.08, 0.84]
)

# Title axes
ax_title = fig.add_subplot(gs[0, 0])
ax_title.axis('off')
ax_title.text(0.5, 0.5, 'Complex Layout Example', 
              fontsize=dm.fs(2), fontweight=dm.fw(1),
              ha='center', va='center',
              transform=ax_title.transAxes)

# Legend axes
ax_legend = fig.add_subplot(gs[1, 0])
ax_legend.axis('off')
line_dummy, = ax_legend.plot(
    [], [], color='dm.red5', linewidth=0.7, label='Data'
)
ax_legend.legend([line_dummy], ['Data'],
                 loc='center', ncol=1,
                 fontsize=dm.fs(-1))

# Plot axes
ax = fig.add_subplot(gs[2, 0])
line, = ax.plot(x, y, color='dm.red5', linewidth=0.7)
ax.set_xlabel('X value [Hour]', fontsize=dm.fs(0))
ax.set_ylabel('Y value [kW]', fontsize=dm.fs(0))

# Annotation (axes 좌표계 사용 - axes 내부에 배치)
ax.annotate('Peak', xy=(np.pi/2, 1), xytext=(np.pi/2, 0.5),
            arrowprops=dict(arrowstyle='->', color='dm.gray5'),
            fontsize=dm.fs(-1), ha='center')

# 레이아웃 최적화
dm.simple_layout(fig, gs=gs)

dm.save_and_show(fig)
```

## 11. GridSpec 전략 가이드

### 11.1 GridSpec 개수 결정 방법

**하나의 GridSpec 사용:**
- Spine alignment가 중요한 axes들이 있을 때
- 모든 axes가 서로 정렬되어야 할 때
- 간단한 레이아웃일 때

**여러 GridSpec 사용:**
- 독립적인 레이아웃 영역이 필요할 때
- Spine alignment가 중요하지 않을 때
- 복잡한 레이아웃일 때

### 11.2 각 GridSpec의 분할 전략

**수직 분할 (nrows 사용):**
- Title, Legend, Plot을 세로로 배치할 때
- 여러 subplot을 세로로 배치할 때

**수평 분할 (ncols 사용):**
- 여러 subplot을 가로로 배치할 때
- Colorbar를 옆에 배치할 때

**복합 분할 (nrows + ncols):**
- 2x2, 3x2 등의 그리드 레이아웃
- 복잡한 다중 subplot 레이아웃

### 11.3 bbox 지정 방법

**전체 figure 사용:**
```python
dm.simple_layout(fig, bbox=(0, 1, 0, 1))  # 기본값
```

**부분 영역 사용:**
```python
# 왼쪽 절반
dm.simple_layout(fig, bbox=(0, 0.5, 0, 1))

# 오른쪽 절반
dm.simple_layout(fig, bbox=(0.5, 1, 0, 1))

# 상단 절반
dm.simple_layout(fig, bbox=(0, 1, 0.5, 1))

# 하단 절반
dm.simple_layout(fig, bbox=(0, 1, 0, 0.5))

# 사용자 정의 영역
dm.simple_layout(fig, bbox=(0.1, 0.9, 0.2, 0.8))
```

## 12. Spine Alignment 고려사항

### 12.1 Spine Alignment가 중요한 경우

여러 axes의 spine이 정렬되어야 할 때는 **하나의 GridSpec으로 구성**하는 것이 좋습니다.

**예시: 공유된 x축 또는 y축**

```python
import numpy as np
import matplotlib.pyplot as plt
import dartwork_mpl as dm

dm.style.use_preset('scientific')

# 데이터
x = np.linspace(0, 10, 100)
y1 = np.sin(x)
y2 = np.cos(x)

# Figure 생성
fig = plt.figure(figsize=(dm.cm2in(9), dm.cm2in(14)), dpi=200)

# 하나의 GridSpec으로 구성 (spine alignment 유지)
gs = fig.add_gridspec(
    nrows=2, ncols=1,
    left=0.17, right=0.95,
    top=0.95, bottom=0.1,
    hspace=0.3
)

# 첫 번째 axes
ax1 = fig.add_subplot(gs[0, 0])
ax1.plot(x, y1, color='dm.red5', linewidth=0.7)
ax1.set_ylabel('Y1 value', fontsize=dm.fs(0))
ax1.set_title('Top Plot', fontsize=dm.fs(1))
ax1.tick_params(labelbottom=False)  # x축 라벨 숨김

# 두 번째 axes (x축 공유)
ax2 = fig.add_subplot(gs[1, 0], sharex=ax1)
ax2.plot(x, y2, color='dm.blue5', linewidth=0.7)
ax2.set_xlabel('X value [Hour]', fontsize=dm.fs(0))
ax2.set_ylabel('Y2 value', fontsize=dm.fs(0))
ax2.set_title('Bottom Plot', fontsize=dm.fs(1))

# 레이아웃 최적화
# 하나의 GridSpec이므로 spine alignment가 유지됨
dm.simple_layout(fig, gs=gs)

dm.save_and_show(fig)
```

### 12.2 Spine Alignment가 중요하지 않은 경우

Spine alignment가 중요하지 않을 때는 **분리된 GridSpec으로 구성**해도 됩니다.

**예시: 독립적인 subplot들**

```python
import numpy as np
import matplotlib.pyplot as plt
import dartwork_mpl as dm

dm.style.use_preset('scientific')

# 데이터
x = np.linspace(0, 10, 100)
y1 = np.sin(x)
y2 = np.cos(x)

# Figure 생성
fig = plt.figure(figsize=(dm.cm2in(17), dm.cm2in(7)), dpi=200)

# 왼쪽 GridSpec
gs_left = fig.add_gridspec(
    nrows=1, ncols=1,
    left=0.1, right=0.48,
    top=0.95, bottom=0.15
)
ax_left = fig.add_subplot(gs_left[0, 0])
ax_left.plot(x, y1, color='dm.red5', linewidth=0.7)
ax_left.set_xlabel('X value [Hour]', fontsize=dm.fs(0))
ax_left.set_ylabel('Y value [kW]', fontsize=dm.fs(0))
ax_left.set_title('Left Plot', fontsize=dm.fs(1))

# 오른쪽 GridSpec
gs_right = fig.add_gridspec(
    nrows=1, ncols=1,
    left=0.52, right=0.9,
    top=0.95, bottom=0.15
)
ax_right = fig.add_subplot(gs_right[0, 0])
ax_right.plot(x, y2, color='dm.blue5', linewidth=0.7)
ax_right.set_xlabel('X value [Hour]', fontsize=dm.fs(0))
ax_right.set_ylabel('Y value [kW]', fontsize=dm.fs(0))
ax_right.set_title('Right Plot', fontsize=dm.fs(1))

# 각 GridSpec을 독립적으로 최적화
dm.simple_layout(
    fig, gs=gs_left, bbox=(0.1, 0.48, 0.15, 0.95), use_all_axes=False
)
dm.simple_layout(
    fig, gs=gs_right, bbox=(0.52, 0.9, 0.15, 0.95), use_all_axes=False
)

dm.save_and_show(fig)
```

## 13. use_all_axes 주의사항

### 13.1 use_all_axes의 작동 방식

`use_all_axes=True` (기본값)일 때:
- **모든 axes의 tightbbox를 고려**합니다.
- 하지만 **최적화되는 것은 주어진 GridSpec (또는 첫 번째 GridSpec)의 파라미터뿐**입니다.

### 13.2 문제 상황

여러 GridSpec이 있을 때 `use_all_axes=True`를 사용하면:
- 모든 axes의 tightbbox를 고려하지만
- 최적화는 첫 번째 GridSpec만 수행되므로
- 다른 GridSpec의 axes는 고려되지만 최적화되지 않아 예상치 못한 결과가 발생할 수 있습니다.

**예시: 문제가 발생하는 경우**

```python
import numpy as np
import matplotlib.pyplot as plt
import dartwork_mpl as dm

dm.style.use_preset('scientific')

# 데이터
x = np.linspace(0, 10, 100)
y1 = np.sin(x)
y2 = np.cos(x)

# Figure 생성
fig = plt.figure(figsize=(dm.cm2in(17), dm.cm2in(7)), dpi=200)

# 왼쪽 GridSpec
gs_left = fig.add_gridspec(
    nrows=1, ncols=1,
    left=0.1, right=0.48,
    top=0.95, bottom=0.15
)
ax_left = fig.add_subplot(gs_left[0, 0])
ax_left.plot(x, y1, color='dm.red5', linewidth=0.7)
ax_left.set_xlabel('X value [Hour]', fontsize=dm.fs(0))
ax_left.set_ylabel('Y value [kW]', fontsize=dm.fs(0))

# 오른쪽 GridSpec
gs_right = fig.add_gridspec(
    nrows=1, ncols=1,
    left=0.52, right=0.9,
    top=0.95, bottom=0.15
)
ax_right = fig.add_subplot(gs_right[0, 0])
ax_right.plot(x, y2, color='dm.blue5', linewidth=0.7)
ax_right.set_xlabel('X value [Hour]', fontsize=dm.fs(0))
ax_right.set_ylabel('Y value [kW]', fontsize=dm.fs(0))

# use_all_axes=True로 최적화 (문제 발생 가능)
# ax_left와 ax_right 모두 tightbbox 계산에 포함되지만
# 최적화는 gs_left만 수행됨
dm.simple_layout(fig, gs=gs_left, use_all_axes=True)

# 결과: gs_left만 최적화되고, gs_right는 최적화되지 않음
dm.save_and_show(fig)
```

### 13.3 올바른 사용법

**axes_divider를 사용하는 특수한 케이스가 아니라면 `use_all_axes=False`를 사용**하는 것이 좋습니다.

**예시: 올바른 사용법**

```python
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable
import dartwork_mpl as dm

dm.style.use_preset('scientific')

# 데이터
x = np.linspace(0, 10, 100)
y = np.linspace(0, 10, 100)
X, Y = np.meshgrid(x, y)
Z = np.sin(X) * np.cos(Y)

# Figure 생성
fig = plt.figure(figsize=(dm.cm2in(9), dm.cm2in(7)), dpi=200)

# GridSpec 생성
gs = fig.add_gridspec(
    nrows=1, ncols=1,
    left=0.17, right=0.95,
    top=0.95, bottom=0.17
)
ax = fig.add_subplot(gs[0, 0])

# 플롯
im = ax.contourf(X, Y, Z, cmap='dm.Spectral', levels=20)
ax.set_xlabel('X value', fontsize=dm.fs(0))
ax.set_ylabel('Y value', fontsize=dm.fs(0))

# axes_divider를 사용하여 colorbar axes 생성
divider = make_axes_locatable(ax)
cax = divider.append_axes("right", size="5%", pad=0.12)
cbar = fig.colorbar(im, cax=cax)
cbar.set_label('Intensity', fontsize=dm.fs(-1))
cbar.ax.tick_params(labelsize=dm.fs(-1))

# use_all_axes=False 사용
# gs에 포함된 axes만 최적화
dm.simple_layout(fig, gs=gs, use_all_axes=False)

dm.save_and_show(fig)
```

## 14. Best Practices

### 14.1 레이아웃 설계 원칙

1. **명확한 계층 구조**: Title → Legend → Plot 순서로 위에서 아래로 배치
2. **충분한 여백**: 요소 간 간격을 충분히 확보
3. **일관된 스타일**: 동일한 레이아웃 패턴을 일관되게 사용

### 14.2 코드 작성 권장사항

1. **Cascading 계산**: 위에서 아래로 순차적으로 계산
2. **변수화**: 하드코딩된 값은 변수로 만들어 재사용
3. **주석 추가**: 레이아웃 계산 로직에 주석 추가

### 14.3 디버깅 팁

1. **단계별 확인**: 각 단계마다 `dm.save_and_show()`로 확인
2. **bbox 시각화**: bbox 영역을 시각화하여 확인
3. **verbose 모드**: `verbose=True`로 최적화 과정 확인

**예시: 디버깅용 bbox 시각화**

```python
import numpy as np
import matplotlib.pyplot as plt
import dartwork_mpl as dm
from matplotlib.patches import Rectangle

dm.style.use_preset('scientific')

# 데이터
x = np.linspace(0, 10, 100)
y = np.sin(x)

# Figure 생성
fig = plt.figure(figsize=(dm.cm2in(9), dm.cm2in(7)), dpi=200)

# 레이아웃 계산
title_y = 0.98
legend_y = 0.93
figure_top = 0.87
figure_bottom = 0.1
left_margin = 0.17
right_margin = 0.95

# GridSpec 생성
gs = fig.add_gridspec(
    nrows=1, ncols=1,
    left=left_margin,
    right=right_margin,
    top=figure_top,
    bottom=figure_bottom
)
ax = fig.add_subplot(gs[0, 0])

# 플롯
ax.plot(x, y, color='dm.red5', linewidth=0.7)
ax.set_xlabel('X value [Hour]', fontsize=dm.fs(0))
ax.set_ylabel('Y value [kW]', fontsize=dm.fs(0))

# 하드코딩된 요소
fig.text(0.5, title_y, 'Title', 
         fontsize=dm.fs(2), fontweight=dm.fw(1),
         ha='center', va='top')

# 디버깅: bbox 영역 시각화
bbox_rect = Rectangle(
    (left_margin, figure_bottom),
    right_margin - left_margin,
    figure_top - figure_bottom,
    transform=fig.transFigure,
    fill=False,
    edgecolor='red',
    linewidth=2,
    linestyle='--'
)
fig.patches.append(bbox_rect)

# 레이아웃 최적화
dm.simple_layout(
    fig,
    gs=gs,
    bbox=(left_margin, right_margin, figure_bottom, figure_top),
    use_all_axes=False
)

dm.save_and_show(fig)
```

## 15. 요약

### 15.1 핵심 원칙

1. **simple_layout은 GridSpec 파라미터만 최적화**: figure 좌표계 요소는 고려되지 않음
2. **하드코딩 요소는 bbox 밖에 배치**: 또는 GridSpec 내부에 포함
3. **Spine alignment가 중요하면 하나의 GridSpec 사용**
4. **독립적인 레이아웃은 분리된 GridSpec 사용**
5. **use_all_axes는 특수 케이스에서만 사용**

### 15.2 해법 선택 가이드

| 상황 | 권장 해법 |
|------|----------|
| Title/Legend가 있는 간단한 플롯 | 해법 1: bbox 작게 설정 |
| Colorbar가 있는 플롯 | 해법 2: axes_divider 사용 |
| 복잡한 다중 요소 레이아웃 | 해법 3: GridSpec 내부에 포함 |
| 독립적인 subplot들 | 해법 4: 독립적인 GridSpec |
| 복합 레이아웃 | 해법 5: 여러 해법 조합 |

### 15.3 체크리스트

레이아웃을 설계할 때 다음을 확인하세요:

- [ ] 하드코딩된 요소가 있는가? → bbox 조정 또는 GridSpec 내부 포함
- [ ] Spine alignment가 중요한가? → 하나의 GridSpec 사용
- [ ] 독립적인 레이아웃이 필요한가? → 분리된 GridSpec 사용
- [ ] use_all_axes를 사용하는가? → 특수 케이스인지 확인
- [ ] 각 GridSpec의 bbox가 올바르게 지정되었는가?
- [ ] 요소 간 간격이 충분한가?
- [ ] 레이아웃이 일관되게 적용되었는가?

---

**마지막 업데이트**: 2025년

**참고**: 이 가이드는 `dartwork-mpl`의 `simple_layout` 함수 사용법을 설명합니다. 더 자세한 내용은 [USAGE_GUIDE.mdc](.cursor/rules/USAGE_GUIDE.mdc)와 [CODING_RULES.mdc](.cursor/rules/CODING_RULES.mdc)를 참고하세요.
