---
alwaysApply: true
---
## 2. 패키지 설치 시 그룹 설정

### 규칙
패키지를 설치할 때 반드시 다음을 확인하고 적절한 그룹에 설치:
- **라이브러리 종속성**: 프로덕션 코드에서 사용되는 패키지 → `uv add <package>`
- **개발 종속성**: 개발/테스트/빌드에만 필요한 패키지 → `uv add --dev <package>`

### 예시

```bash
# 라이브러리 종속성 (프로덕션에서 사용)
uv add numpy matplotlib pandas

# 개발 종속성 (테스트, 린팅, 문서화 등)
uv add --dev pytest pytest-cov ruff black sphinx

# 선택적 종속성 그룹
uv add --optional jupyter  # 선택적 기능을 위한 패키지
```

### 설명
`pyproject.toml`에서 다음과 같이 구분됩니다:

```toml
[project]
dependencies = [
    "numpy>=1.20.0",
    "matplotlib>=3.5.0",
]

[project.optional-dependencies]
dev = [
    "pytest>=7.0.0",
    "ruff>=0.1.0",
]
```

### 사용해야 하는 이유
1. **배포 최적화**: 프로덕션 환경에서는 개발 도구가 필요 없으므로 설치 시간과 용량 절약
2. **명확한 의존성 관리**: 어떤 패키지가 실제 기능에 필요한지 명확히 구분
3. **CI/CD 효율성**: 프로덕션 빌드와 개발 환경을 분리하여 빌드 시간 단축
4. **보안**: 불필요한 개발 도구를 프로덕션에 포함하지 않아 공격 표면 감소

---

## 3. NumPy 스타일 Docstring

### 규칙
모든 함수, 클래스, 모듈에 NumPy 스타일 docstring을 작성합니다.

### 예시

```python
def calculate_statistics(
    data: list[float],
    method: str = "mean"
) -> dict[str, float]:
    """
    Calculate statistical measures for a given dataset.

    This function computes various statistical measures including mean,
    median, and standard deviation based on the specified method.

    Parameters
    ----------
    data : list[float]
        A list of numerical values to analyze. Must contain at least
        one element.
    method : str, optional
        The statistical method to use. Options are:
        - "mean": Calculate mean and standard deviation
        - "median": Calculate median and median absolute deviation
        Default is "mean".

    Returns
    -------
    dict[str, float]
        A dictionary containing the calculated statistics. Keys include:
        - "value": The main statistical measure
        - "deviation": The associated deviation measure

    Raises
    ------
    ValueError
        If `data` is empty or `method` is not one of the supported options.
    TypeError
        If `data` contains non-numeric values.

    Examples
    --------
    >>> data = [1.0, 2.0, 3.0, 4.0, 5.0]
    >>> result = calculate_statistics(data, method="mean")
    >>> print(result["value"])
    3.0

    >>> result = calculate_statistics(data, method="median")
    >>> print(result["value"])
    3.0

    Notes
    -----
    The function uses NumPy for calculations if available, otherwise
    falls back to standard library functions.

    See Also
    --------
    numpy.mean : NumPy's mean function
    numpy.median : NumPy's median function

    References
    ----------
    .. [1] Statistical Methods for Data Analysis, 2020.
    """
    if not data:
        raise ValueError("Data cannot be empty")
    
    # Implementation here...
    pass
```

### 설명
NumPy 스타일 docstring 구조:
- **Short summary**: 한 줄 요약
- **Extended summary**: 상세 설명 (선택)
- **Parameters**: 매개변수 설명
- **Returns**: 반환값 설명
- **Raises**: 예외 설명
- **Examples**: 사용 예시
- **Notes**: 추가 참고사항
- **See Also**: 관련 함수/클래스
- **References**: 참고 자료

### 사용해야 하는 이유
1. **표준화**: Python 과학 계산 생태계에서 널리 사용되는 표준 형식
2. **자동 문서화**: Sphinx와 같은 도구로 자동 API 문서 생성 가능
3. **IDE 지원**: 많은 IDE에서 docstring을 자동으로 표시하여 개발자 경험 향상
4. **완전성**: 매개변수, 반환값, 예외를 체계적으로 문서화하여 코드 이해도 향상

---

## 4. Python 3.10+ 타입 힌트

### 규칙
Python 3.10 이상 버전의 타입 힌트를 사용합니다. `typing` 모듈의 대문자 타입 대신 내장 타입을 사용합니다.

### 예시

```python
# ❌ 잘못된 방법 (Python 3.9 이하 스타일)
from typing import List, Dict, Tuple, Optional, Union

def process_data(
    items: List[str],
    config: Dict[str, int],
    coordinates: Tuple[float, float],
    value: Optional[int] = None,
    mode: Union[str, int] = "default"
) -> List[Dict[str, str]]:
    pass

# ✅ 올바른 방법 (Python 3.10+ 스타일)
def process_data(
    items: list[str],
    config: dict[str, int],
    coordinates: tuple[float, float],
    value: int | None = None,
    mode: str | int = "default"
) -> list[dict[str, str]]:
    pass

# ✅ 복잡한 타입도 내장 타입 사용
from collections.abc import Callable, Iterator

def apply_function(
    func: Callable[[int, str], bool],
    data: Iterator[int]
) -> list[bool]:
    pass
```

### 설명
Python 3.10+에서 도입된 변경사항:
- `List[T]` → `list[T]`
- `Dict[K, V]` → `dict[K, V]`
- `Tuple[T, ...]` → `tuple[T, ...]`
- `Optional[T]` → `T | None`
- `Union[A, B]` → `A | B`

### 사용해야 하는 이유
1. **간결성**: 코드가 더 읽기 쉽고 간결해짐
2. **표준**: Python 3.10+의 공식 권장 방식
3. **성능**: 내장 타입 사용으로 약간의 성능 향상
4. **미래 지향적**: 최신 Python 기능 활용으로 코드 유지보수성 향상
5. **타입 체커 지원**: mypy, pyright 등 모든 주요 타입 체커에서 완전 지원

---

## 5. Git 커밋 시 임시 파일 확인

### 규칙
커밋 전에 다음을 확인:
1. 임시 파일이나 생성 파일이 포함되어 있는지 확인
2. 임시 파일이면 `.gitignore`에 추가할지 사용자에게 확인
3. `.gitignore`에 추가해야 한다면 추가 후 커밋

### 예시

```bash
# 커밋 전 확인해야 할 파일들
__pycache__/
*.pyc
*.pyo
*.pyd
.Python
*.so
*.egg
*.egg-info/
dist/
build/
.pytest_cache/
.coverage
htmlcov/
*.log
.env
.venv/
venv/
*.swp
*.swo
*~
.DS_Store
```

### 설명
일반적인 임시/생성 파일 패턴:
- **캐시 파일**: `__pycache__/`, `*.pyc`
- **빌드 산출물**: `dist/`, `build/`, `*.egg-info/`
- **테스트 산출물**: `.pytest_cache/`, `.coverage`, `htmlcov/`
- **환경 파일**: `.venv/`, `venv/`, `.env`
- **에디터 파일**: `*.swp`, `.vscode/`, `.idea/`

### 사용해야 하는 이유
1. **저장소 크기**: 불필요한 파일로 인한 저장소 크기 증가 방지
2. **충돌 방지**: 빌드 산출물은 환경마다 다를 수 있어 충돌 발생 가능
3. **보안**: `.env` 파일 등 민감한 정보가 커밋되는 것 방지
4. **명확성**: 실제 소스 코드만 추적하여 변경 이력 명확화
5. **성능**: Git이 추적할 파일 수 감소로 성능 향상

---

## 6. TypeScript 스타일: 모든 구현에 타입 힌트 필수

### 규칙
TypeScript처럼 모든 함수, 변수, 클래스 속성에 타입 힌트를 명시합니다.

### 예시

```python
# ❌ 타입 힌트 없음
def process_data(data, threshold):
    result = []
    for item in data:
        if item > threshold:
            result.append(item * 2)
    return result

# ✅ 타입 힌트 포함
def process_data(
    data: list[float],
    threshold: float
) -> list[float]:
    result: list[float] = []
    for item in data:
        if item > threshold:
            result.append(item * 2)
    return result

# ✅ 클래스 속성도 타입 힌트
class DataProcessor:
    def __init__(self, config: dict[str, str]) -> None:
        self.config: dict[str, str] = config
        self.cache: dict[str, list[float]] = {}
        self.is_initialized: bool = False
    
    def process(self, data: list[float]) -> dict[str, float]:
        if not self.is_initialized:
            self._initialize()
        
        result: dict[str, float] = {}
        for key, value in self.cache.items():
            result[key] = sum(value) / len(value)
        return result
    
    def _initialize(self) -> None:
        self.is_initialized = True
```

### 설명
타입 힌트를 사용해야 하는 모든 위치:
- 함수 매개변수
- 함수 반환값
- 변수 선언 (특히 복잡한 타입)
- 클래스 속성
- 메서드 매개변수 및 반환값

### 사용해야 하는 이유
1. **가독성**: 코드를 읽는 사람이 즉시 타입을 이해 가능
2. **IDE 지원**: 자동완성, 타입 체크, 리팩토링 지원 향상
3. **버그 방지**: 타입 불일치를 조기에 발견
4. **문서화**: 타입 힌트 자체가 문서 역할
5. **유지보수**: 대규모 프로젝트에서 코드 변경 시 영향 범위 파악 용이
6. **팀 협업**: 다른 개발자가 코드를 이해하는 시간 단축

---

## 7. 사용하지 않는 Import 제거

### 규칙
코드에서 실제로 사용하지 않는 import 문은 모두 제거합니다.

### 예시

```python
# ❌ 사용하지 않는 import 포함
import os
import sys
import json
from pathlib import Path
from typing import Optional  # 사용하지 않음

def read_file(filepath: str) -> str:
    path = Path(filepath)
    with open(path, 'r') as f:
        return f.read()

# ✅ 사용하는 import만 포함
from pathlib import Path

def read_file(filepath: str) -> str:
    path = Path(filepath)
    with open(path, 'r') as f:
        return f.read()
```

### 설명
사용하지 않는 import를 찾는 방법:
- **자동 도구**: `ruff check --select F401` 또는 `ruff check --select F`
- **IDE 기능**: 대부분의 IDE가 사용하지 않는 import를 회색으로 표시
- **수동 확인**: 각 import가 코드에서 실제로 사용되는지 확인

### 사용해야 하는 이유
1. **명확성**: 실제로 사용하는 의존성만 표시하여 코드 의도 명확화
2. **성능**: 불필요한 모듈 로딩으로 인한 시작 시간 단축
3. **유지보수**: 의존성 관리가 쉬워짐
4. **가독성**: import 섹션이 깔끔해져 코드 가독성 향상
5. **린팅**: 대부분의 린터가 사용하지 않는 import를 경고

---

## 8. 파일 최상단이 아닌 Import 사용 금지

### 규칙
논리적으로 설명 가능한 명확한 이유가 없으면 파일 최상단이 아닌 곳에서 import를 사용하지 않습니다.

### 허용되는 예외
- 환경 변수 설정을 위한 `import os`
- 조건부 import (플랫폼별 모듈)
- 순환 import 방지
- 지연 로딩이 필요한 무거운 모듈

### 예시

```python
# ❌ 불필요한 중간 import
def process_data(data: list[float]) -> list[float]:
    import numpy as np  # 최상단으로 이동해야 함
    return np.array(data).tolist()

# ✅ 최상단 import
import numpy as np

def process_data(data: list[float]) -> list[float]:
    return np.array(data).tolist()

# ✅ 허용되는 예외 1: 환경 변수 설정
import os
os.environ['PYTHONPATH'] = '/custom/path'

# ✅ 허용되는 예외 2: 조건부 import
if sys.platform == 'win32':
    import winreg
else:
    import subprocess

# ✅ 허용되는 예외 3: 순환 import 방지
def get_config():
    from .config import settings  # 순환 import 방지
    return settings

# ✅ 허용되는 예외 4: 지연 로딩 (무거운 모듈)
def plot_data(data: list[float]) -> None:
    import big_lib as big_lib  # 함수 호출 시에만 로드
    ...
```

### 설명
파일 최상단 import를 사용해야 하는 이유:
- **명확성**: 파일의 의존성을 한눈에 파악 가능
- **일관성**: 모든 Python 파일이 동일한 구조를 따름
- **성능**: 모듈 로딩이 한 번만 발생 (중간 import는 매번 로딩)
- **디버깅**: import 오류를 조기에 발견

### 사용해야 하는 이유
1. **PEP 8 준수**: Python 스타일 가이드 권장사항
2. **가독성**: 의존성을 파일 상단에서 한 번에 확인
3. **성능**: 모듈 로딩 오버헤드 최소화
4. **일관성**: 팀 전체가 동일한 패턴을 따름
5. **도구 지원**: 린터와 포맷터가 최상단 import를 기대

---

## 9. Ruff를 사용한 코드 포맷팅 및 80컬럼 제한

### 규칙
코드 작성 후 반드시 ruff를 사용하여 포맷팅을 수행하며, 80컬럼을 넘지 않도록 합니다. 특정 제한을 제거해야 할 경우 사용자에게 이유를 설명하고 ignore 처리합니다.

### 예시

```bash
# 포맷팅 실행
uvx ruff format .

# 린팅 체크
uvx ruff check .

# 특정 파일만 포맷팅
uvx ruff format src/dartwork_mpl/color.py

# 특정 라인만 ignore (80컬럼 초과 허용)
def very_long_function_name_that_exceeds_eighty_columns(
    parameter_one: str,
    parameter_two: int,
    parameter_three: list[float]
) -> dict[str, str]:  # noqa: E501
    pass
```

### Ruff 설정 예시 (`pyproject.toml`)

```toml
[tool.ruff]
line-length = 80
target-version = "py310"

[tool.ruff.format]
quote-style = "double"
indent-style = "space"
skip-magic-trailing-comma = false
line-ending = "auto"

[tool.ruff.lint]
select = [
    "E",   # pycodestyle errors
    "W",   # pycodestyle warnings
    "F",   # pyflakes
    "I",   # isort
    "B",   # flake8-bugbear
    "C4",  # flake8-comprehensions
    "UP",  # pyupgrade
]
ignore = [
    "E501",  # line too long (handled by formatter)
]

[tool.ruff.lint.isort]
known-first-party = ["dartwork_mpl"]
```

### 80컬럼 제한을 유지해야 하는 이유
1. **가독성**: 작은 화면에서도 코드를 편하게 볼 수 있음
2. **병렬 작업**: 두 파일을 나란히 열어 비교하기 쉬움
3. **인쇄**: 코드를 인쇄할 때 페이지 너비에 맞춤
4. **표준**: 많은 프로젝트와 스타일 가이드에서 권장
5. **Git diff**: 변경사항을 한눈에 파악하기 쉬움

### 예외 처리 예시

```python
# ✅ 긴 URL이나 문자열은 예외 허용
# URL이 80자를 초과하는 경우
API_ENDPOINT = (
    "https://very-long-api-endpoint-url-that-exceeds-"
    "eighty-characters.com/api/v1/endpoint"
)

# ✅ 긴 타입 힌트는 여러 줄로 분리
def complex_function(
    data: dict[
        str,
        list[tuple[float, float, dict[str, str]]]
    ]
) -> dict[
    str,
    list[tuple[float, float, dict[str, str]]]
]:
    pass

# ✅ 주석이 긴 경우
# This is a very long comment that explains something complex
# and needs to span multiple lines to be clear and comprehensive.
def function():
    pass
```

### 사용해야 하는 이유
1. **일관성**: 모든 코드가 동일한 스타일로 포맷팅됨
2. **자동화**: 수동 포맷팅 시간 절약
3. **품질**: 린팅 규칙으로 코드 품질 향상
4. **협업**: 팀 전체가 동일한 코드 스타일 유지
5. **CI/CD 통합**: 커밋 전 자동 포맷팅 및 검사 가능

---

## 요약 체크리스트

코드를 작성하거나 수정할 때 다음을 확인하세요:

- [ ] `uv`를 사용하여 패키지를 설치했는가?
- [ ] 패키지를 적절한 그룹(라이브러리/개발)에 설치했는가?
- [ ] 모든 함수/클래스에 NumPy 스타일 docstring을 작성했는가?
- [ ] Python 3.10+ 타입 힌트를 사용했는가? (`list[str]` vs `List[str]`)
- [ ] 모든 구현에 타입 힌트를 포함했는가?
- [ ] 사용하지 않는 import를 제거했는가?
- [ ] import가 파일 최상단에 있는가? (명확한 이유 없이 중간에 있지 않은가?)
- [ ] `ruff format`으로 포맷팅을 수행했는가?
- [ ] 80컬럼 제한을 준수했는가? (예외가 있다면 이유를 문서화했는가?)
- [ ] 커밋 전에 임시 파일이 포함되지 않았는지 확인했는가?
- [ ] `.gitignore`에 필요한 항목이 추가되었는가?

---

## 추가 참고사항

### Ruff 명령어 요약

```bash
# 포맷팅
uvx ruff format .                    # 전체 포맷팅
uvx ruff format src/                  # 특정 디렉토리
uvx ruff format --check .             # 포맷팅 필요 여부만 확인

# 린팅
uvx ruff check .                      # 전체 체크
uvx ruff check --fix .                # 자동 수정 가능한 문제 수정
uvx ruff check src/dartwork_mpl/     # 특정 디렉토리만 체크

# 특정 규칙만 체크
uvx ruff check --select E,W,F .      # 에러, 경고, pyflakes만
```

### 프로젝트 구조 권장사항

```
dartwork-mpl/
├── .gitignore                        # Git 무시 파일
├── pyproject.toml                    # 프로젝트 설정 (ruff 포함)
├── uv.lock                           # uv 잠금 파일
├── README.md                         # 프로젝트 설명
├── CODING_RULES.md                   # 이 파일
└── src/
    └── dartwork_mpl/
        └── ...
```

---

**마지막 업데이트**: 2025년

**참고**: 이 규칙들은 프로젝트의 일관성과 품질을 유지하기 위해 설정되었습니다. 특별한 경우 예외가 필요하다면 팀과 논의 후 결정하세요.

